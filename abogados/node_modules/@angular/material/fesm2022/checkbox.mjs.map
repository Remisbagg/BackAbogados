{"version":3,"file":"checkbox.mjs","sources":["../../../../../../src/material/checkbox/checkbox-config.ts","../../../../../../src/material/checkbox/checkbox.ts","../../../../../../src/material/checkbox/checkbox.html","../../../../../../src/material/checkbox/checkbox-required-validator.ts","../../../../../../src/material/checkbox/module.ts","../../../../../../src/material/checkbox/checkbox_public_index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectionToken} from '@angular/core';\nimport {ThemePalette} from '@angular/material/core';\n\n/** Default `mat-checkbox` options that can be overridden. */\nexport interface MatCheckboxDefaultOptions {\n  /** Default theme color palette to be used for checkboxes. */\n  color?: ThemePalette;\n  /** Default checkbox click action for checkboxes. */\n  clickAction?: MatCheckboxClickAction;\n}\n\n/** Injection token to be used to override the default options for `mat-checkbox`. */\nexport const MAT_CHECKBOX_DEFAULT_OPTIONS = new InjectionToken<MatCheckboxDefaultOptions>(\n  'mat-checkbox-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY(): MatCheckboxDefaultOptions {\n  return {\n    color: 'accent',\n    clickAction: 'check-indeterminate',\n  };\n}\n\n/**\n * Checkbox click action when user click on input element.\n * noop: Do not toggle checked or indeterminate.\n * check: Only toggle checked status, ignore indeterminate.\n * check-indeterminate: Toggle checked status, set indeterminate to false. Default behavior.\n * undefined: Same as `check-indeterminate`.\n */\nexport type MatCheckboxClickAction = 'noop' | 'check' | 'check-indeterminate' | undefined;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterViewInit,\n  Attribute,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  Input,\n  NgZone,\n  numberAttribute,\n  OnChanges,\n  Optional,\n  Output,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation,\n  ANIMATION_MODULE_TYPE,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  NG_VALIDATORS,\n  NG_VALUE_ACCESSOR,\n  ValidationErrors,\n  Validator,\n} from '@angular/forms';\nimport {_MatInternalFormField, MatRipple} from '@angular/material/core';\nimport {FocusableOption} from '@angular/cdk/a11y';\nimport {\n  MAT_CHECKBOX_DEFAULT_OPTIONS,\n  MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY,\n  MatCheckboxDefaultOptions,\n} from './checkbox-config';\n\n/**\n * Represents the different states that require custom transitions between them.\n * @docs-private\n */\nexport enum TransitionCheckState {\n  /** The initial state of the component before any user interaction. */\n  Init,\n  /** The state representing the component when it's becoming checked. */\n  Checked,\n  /** The state representing the component when it's becoming unchecked. */\n  Unchecked,\n  /** The state representing the component when it's becoming indeterminate. */\n  Indeterminate,\n}\n\n/**\n * @deprecated Will stop being exported.\n * @breaking-change 19.0.0\n */\nexport const MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatCheckbox),\n  multi: true,\n};\n\n/** Change event object emitted by checkbox. */\nexport class MatCheckboxChange {\n  /** The source checkbox of the event. */\n  source: MatCheckbox;\n  /** The new `checked` value of the checkbox. */\n  checked: boolean;\n}\n\n// Increasing integer for generating unique ids for checkbox components.\nlet nextUniqueId = 0;\n\n// Default checkbox configuration.\nconst defaults = MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();\n\n@Component({\n  selector: 'mat-checkbox',\n  templateUrl: 'checkbox.html',\n  styleUrls: ['checkbox.css'],\n  host: {\n    'class': 'mat-mdc-checkbox',\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[class._mat-animation-noopable]': `_animationMode === 'NoopAnimations'`,\n    '[class.mdc-checkbox--disabled]': 'disabled',\n    '[id]': 'id',\n    // Add classes that users can use to more easily target disabled or checked checkboxes.\n    '[class.mat-mdc-checkbox-disabled]': 'disabled',\n    '[class.mat-mdc-checkbox-checked]': 'checked',\n    '[class]': 'color ? \"mat-\" + color : \"mat-accent\"',\n  },\n  providers: [\n    MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR,\n    {\n      provide: NG_VALIDATORS,\n      useExisting: MatCheckbox,\n      multi: true,\n    },\n  ],\n  exportAs: 'matCheckbox',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  standalone: true,\n  imports: [MatRipple, _MatInternalFormField],\n})\nexport class MatCheckbox\n  implements AfterViewInit, OnChanges, ControlValueAccessor, Validator, FocusableOption\n{\n  /** Focuses the checkbox. */\n  focus() {\n    this._inputElement.nativeElement.focus();\n  }\n\n  /** Creates the change event that will be emitted by the checkbox. */\n  protected _createChangeEvent(isChecked: boolean) {\n    const event = new MatCheckboxChange();\n    event.source = this;\n    event.checked = isChecked;\n    return event;\n  }\n\n  /** Gets the element on which to add the animation CSS classes. */\n  protected _getAnimationTargetElement() {\n    return this._inputElement?.nativeElement;\n  }\n\n  /** CSS classes to add when transitioning between the different checkbox states. */\n  protected _animationClasses = {\n    uncheckedToChecked: 'mdc-checkbox--anim-unchecked-checked',\n    uncheckedToIndeterminate: 'mdc-checkbox--anim-unchecked-indeterminate',\n    checkedToUnchecked: 'mdc-checkbox--anim-checked-unchecked',\n    checkedToIndeterminate: 'mdc-checkbox--anim-checked-indeterminate',\n    indeterminateToChecked: 'mdc-checkbox--anim-indeterminate-checked',\n    indeterminateToUnchecked: 'mdc-checkbox--anim-indeterminate-unchecked',\n  };\n\n  /**\n   * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n   * take precedence so this may be omitted.\n   */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /**\n   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n   */\n  @Input('aria-labelledby') ariaLabelledby: string | null = null;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  private _uniqueId: string;\n\n  /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n  @Input() id: string;\n\n  /** Returns the unique id for the visual hidden input. */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether the checkbox is required. */\n  @Input({transform: booleanAttribute}) required: boolean;\n\n  /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n  @Input() labelPosition: 'before' | 'after' = 'after';\n\n  /** Name value will be applied to the input element if present */\n  @Input() name: string | null = null;\n\n  /** Event emitted when the checkbox's `checked` value changes. */\n  @Output() readonly change = new EventEmitter<MatCheckboxChange>();\n\n  /** Event emitted when the checkbox's `indeterminate` value changes. */\n  @Output() readonly indeterminateChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** The value attribute of the native input element */\n  @Input() value: string;\n\n  /** Whether the checkbox has a ripple. */\n  @Input({transform: booleanAttribute}) disableRipple: boolean;\n\n  /** The native `<input type=\"checkbox\">` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** The native `<label>` element */\n  @ViewChild('label') _labelElement: ElementRef<HTMLInputElement>;\n\n  /** Tabindex for the checkbox. */\n  @Input({transform: (value: unknown) => (value == null ? undefined : numberAttribute(value))})\n  tabIndex: number;\n\n  // TODO(crisbeto): this should be a ThemePalette, but some internal apps were abusing\n  // the lack of type checking previously and assigning random strings.\n  /** Palette color of the checkbox. */\n  @Input() color: string | undefined;\n\n  /**\n   * Reference to the MatRipple instance of the checkbox.\n   * @deprecated Considered an implementation detail. To be removed.\n   * @breaking-change 17.0.0\n   */\n  @ViewChild(MatRipple) ripple: MatRipple;\n\n  /**\n   * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n   * @docs-private\n   */\n  _onTouched: () => any = () => {};\n\n  private _currentAnimationClass: string = '';\n  private _currentCheckState: TransitionCheckState = TransitionCheckState.Init;\n  private _controlValueAccessorChangeFn: (value: any) => void = () => {};\n  private _validatorChangeFn = () => {};\n\n  constructor(\n    public _elementRef: ElementRef<HTMLElement>,\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _ngZone: NgZone,\n    @Attribute('tabindex') tabIndex: string,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string,\n    @Optional() @Inject(MAT_CHECKBOX_DEFAULT_OPTIONS) private _options?: MatCheckboxDefaultOptions,\n  ) {\n    this._options = this._options || defaults;\n    this.color = this._options.color || defaults.color;\n    this.tabIndex = parseInt(tabIndex) || 0;\n    this.id = this._uniqueId = `mat-mdc-checkbox-${++nextUniqueId}`;\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['required']) {\n      this._validatorChangeFn();\n    }\n  }\n\n  ngAfterViewInit() {\n    this._syncIndeterminate(this._indeterminate);\n  }\n\n  /** Whether the checkbox is checked. */\n  @Input({transform: booleanAttribute})\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: boolean) {\n    if (value != this.checked) {\n      this._checked = value;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _checked: boolean = false;\n\n  /** Whether the checkbox is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    if (value !== this.disabled) {\n      this._disabled = value;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _disabled: boolean = false;\n\n  /**\n   * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n   * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n   * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n   * set to false.\n   */\n  @Input({transform: booleanAttribute})\n  get indeterminate(): boolean {\n    return this._indeterminate;\n  }\n  set indeterminate(value: boolean) {\n    const changed = value != this._indeterminate;\n    this._indeterminate = value;\n\n    if (changed) {\n      if (this._indeterminate) {\n        this._transitionCheckState(TransitionCheckState.Indeterminate);\n      } else {\n        this._transitionCheckState(\n          this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked,\n        );\n      }\n      this.indeterminateChange.emit(this._indeterminate);\n    }\n\n    this._syncIndeterminate(this._indeterminate);\n  }\n  private _indeterminate: boolean = false;\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  /** Method being called whenever the label text changes. */\n  _onLabelTextChange() {\n    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n    // component will be only marked for check, but no actual change detection runs automatically.\n    // Instead of going back into the zone in order to trigger a change detection which causes\n    // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n    // an explicit change detection for the checkbox view and its children.\n    this._changeDetectorRef.detectChanges();\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: any) {\n    this.checked = !!value;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: any) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n  }\n\n  // Implemented as a part of Validator.\n  validate(control: AbstractControl<boolean>): ValidationErrors | null {\n    return this.required && control.value !== true ? {'required': true} : null;\n  }\n\n  // Implemented as a part of Validator.\n  registerOnValidatorChange(fn: () => void): void {\n    this._validatorChangeFn = fn;\n  }\n\n  private _transitionCheckState(newState: TransitionCheckState) {\n    let oldState = this._currentCheckState;\n    let element = this._getAnimationTargetElement();\n\n    if (oldState === newState || !element) {\n      return;\n    }\n    if (this._currentAnimationClass) {\n      element.classList.remove(this._currentAnimationClass);\n    }\n\n    this._currentAnimationClass = this._getAnimationClassForCheckState